// Generated by CoffeeScript 1.6.3
(function() {
    var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

    angular.module('localytics.directives', []);

    angular.module('localytics.directives').directive('chosen', function() {
        var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/,
            CHOSEN_OPTION_WHITELIST = ['displayDisabledOptions', 'width', 'disableOnAllOptionsDisabled', 'disableSearch', 'searchContains', 'inheritSelectClasses'];

        function snakeCase(input) {
            return input.replace(/[A-Z]/g, function($1) {
                return "_" + ($1.toLowerCase());
            });
        }

        function isEmpty(value) {
            var key;
            if (angular.isArray(value)) {
                return value.length === 0;
            } else if (angular.isObject(value)) {
                for (key in value) {
                    if (value.hasOwnProperty(key)) {
                        return false;
                    }
                }
            }
            return true;
        }

        return {
            restrict: 'A',
            require: '?ngModel',
            priority: 1,
            link: function(scope, element, attr, ctrl) {
                var disableWithMessage, empty, initOrUpdate, initialized, match, options, origRender,
                    removeEmptyMessage, valuesExpr, viewWatch, updateOptionDisableState;

                initOrUpdate = function() {
                    updateOptionDisableState();
                    if (initialized) {
                        return element.trigger('chosen:updated');
                    } else {
                        element.chosen(options);
                        return initialized = true;
                    }
                };

                removeEmptyMessage = function() {
                    empty = false;
                    return element.find('option.empty').remove();
                };

                disableWithMessage = function(message) {
                    empty = true;
                    return element.empty().append("<option selected class=\"empty\">" + message + "</option>").attr('disabled', true).trigger('chosen:updated');
                };

                updateOptionDisableState = function() {
                    if(!!options.display_disabled_options || !attr.blinkDisabledOptions) {
                        return;
                    }

                    var optionValues = scope.$eval(valuesExpr),
                        disabledOptionValues = scope.$eval(attr.blinkDisabledOptions);

                    $("option[value!='?']", element).each(function(i, e) {
                        var optionValue = optionValues[i],
                            isDisabledOption = __indexOf.call(disabledOptionValues, optionValue) >= 0;

                        $(e).prop('disabled', isDisabledOption);
                        if (isDisabledOption) {
                            $(e).removeAttr('selected');
                        }
                    });

                    if (options.disable_on_all_options_disabled) {
                        var enabledOptions = $("option[value!='?']:enabled", element),
                            disabled = enabledOptions.length === 0;

                        element.prop('disabled', disabled);
                        var disabledPlaceholder = element.attr('data-disabled-placeholder'),
                            enabledPlaceholder = element.attr('data-original-data-placeholder');
                        if (!enabledPlaceholder) {
                            enabledPlaceholder = element.attr('data-placeholder');
                            element.attr('data-original-data-placeholder', enabledPlaceholder);
                        }

                        element.attr("data-placeholder", disabled ? disabledPlaceholder : enabledPlaceholder);
                    }
                };

                initialized = false;
                empty = false;
                element.addClass('localytics-chosen');
                options = scope.$eval(attr.chosen) || {};
                angular.forEach(attr, function(value, key) {
                    if (__indexOf.call(CHOSEN_OPTION_WHITELIST, key) >= 0) {
                        return options[snakeCase(key)] = scope.$eval(value);
                    }
                });

                var ngOptions = attr.ngOptions;
                match = ngOptions.match(NG_OPTIONS_REGEXP);
                valuesExpr = match[7];

                if (ctrl) {
                    origRender = ctrl.$render;
                    ctrl.$render = function() {
                        origRender();
                        return initOrUpdate();
                    };
                    if (attr.multiple) {
                        viewWatch = function() {
                            return ctrl.$viewValue;
                        };

                        scope.$watchCollection(viewWatch, function(newVals, oldVals) {
                            // Note(sunny): this is a hack to allow html values
                            // in option labels without having to resort to <option ng-repeat...>
                            // and write an angular-chosen wrapper for that as well.
                            if (attr.hasOwnProperty('blinkOptionsHtml')) {
                                element.children('option').each(function(index){
                                    $(this).html($(this).text());
                                });
                            }

                            ctrl.$render();
                        });
                    }
                } else {
                    initOrUpdate();
                }

                // attr.$observe does not seem to work if the attribute
                // is not set at the time of initialization (e.g. if
                // specified using ng-attr or blink-attr)
                scope.$watch(function(){
                    return element.attr('disabled');
                }, function(){
                    return element.trigger('chosen:updated');
                });

                scope.$watch(function(){
                    return scope.$eval(attr.blinkDisabledOptions);
                }, function(newValue, oldValue){
                    updateOptionDisableState();
                    element.trigger('chosen:updated');
                });

                if (ngOptions) {
                    if (!!options.display_disabled_options) {
                        // TODO(sunny) support x for x in y syntax on blinkDisabledOptions
                        scope.$watchCollection(attr.blinkDisabledOptions, function(newVal, oldVal){
                            if(newVal !== oldVal) {
                                ctrl.$render();
                            }
                        });
                    }

                    return scope.$watchCollection(valuesExpr, function(newVal, oldVal) {
                        if (newVal !== oldVal) {
                            if (empty) {
                                removeEmptyMessage();
                                element.prop('disabled', false);
                            }
                            if (isEmpty(newVal)) {
                                var message = !!attr.blinkLoadingOptions ? '' : (options.no_results_text || 'No values available');
                                return disableWithMessage(message);
                            }

                            element.trigger('chosen:updated');
                        }
                    });
                }
            }
        };
    });

}).call(this);