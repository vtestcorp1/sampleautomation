/**
 * Copyright: ThoughtSpot Inc. 2012-2016
 * Author: Vibhor Nanavati (vibhor@thoughtspot.com),
 * Shikhar Agarwal (shikhar@thoughtspot.com)
 *
 * @fileoverview Data model for visualization column.
 */

'use strict';

import _ from 'lodash';
import {ngRequire, Provide} from 'src/base/decorators';
import {blinkConstants} from '../../../base/blink-constants';
import {strings} from '../../../base/strings';
import GeoConfig from '../../document-model/table-model/geo-config';
import {jsonConstants} from '../../viz-layout/answer/json-constants';
import {ColumnMetricsDefinition} from '../../worksheet/column-metrics';

let CurrencyTypeInfo = ngRequire('CurrencyTypeInfo');
let dateUtil = ngRequire('dateUtil');
let LogicalTableModel = ngRequire('LogicalTableModel');
let util = ngRequire('util');
let Logger = ngRequire('Logger');

declare var icu4js:any;
declare var moment: any;

/**
 * VisualizationColumnModel encapsulates the details of visualization column.
 */
@Provide('VisualizationColumnModel')
export class VisualizationColumnModel {
    private static unsupportedAttributeFilterTypes = [
        'TIME',
        'DATE_NUM_ABS_DAY',
        'DATE_NUM_ABS_MONTH',
        'DATE_NUM_ABS_QUARTER',
        'DATE_NUM_ABS_YEAR',
        'DATE_NUM_DAY_IN_MONTH',
        'DATE_NUM_DAY_IN_QUARTER',
        'DATE_NUM_DAY_IN_YEAR',
        'DATE_NUM_DAY_OF_WEEK',
        'DATE_NUM_MONTH_IN_QUARTER',
        'DATE_NUM_MONTH_IN_YEAR',
        'DATE_NUM_WEEK_IN_YEAR',
        'DATE_NUM_QUARTER_IN_YEAR'
    ];

    private logger = Logger.create('visualization column');

    private genericFormatter = LogicalTableModel.LogicalColumn.genericFormatter;

    private numericFormatter = LogicalTableModel.LogicalColumn.numericFormatter;

    private floatingPointFormatter = LogicalTableModel.LogicalColumn.floatingPointFormatter;

    /**
     * A list of data sources combined together to obtain the information
     * represented by this viz column.
     * The combination of sources can happen due to a join
     * or an expression using a DerivedExpression tree.
     */
    private sources : Array<any>;

    private metricsDefinition: ColumnMetricsDefinition;
    private currencyTypeInfo;
    private data;

    /**
     * The formatter associated with this column.
     * Based on the formatPattern and the effectiveDataType.
     */
    private baseTypeFormatterInstance;
    private numericFormatterInstance;
    private floatingPointFormatterInstance;

    private isFilterColumnProperty : boolean;
    private geoConfig: GeoConfig|undefined;

    /**
     * A wrapper class on the json column definition.
     * The class exposes convenience methods for getting the column name, type, data
     * type or formatter.
     * It encapsulates the json details from rest of the app.
     *
     * Note(Shikhar) - Currently many methods like getGuid, etc forwards call to LogicalColumn.
     * This is because Viz Column contains Logical Column and these methods derive their data
     * from Logical Column json.
     * We are forwarding these as of now because there are many call sites that assume that
     * these methods are part of Viz column prototype.
     *
     * TODO (Shikhar) - Clean up the sites that use the logical column forwarding methods to
     * use logical column directly
     *
     * @constructor
     */
    constructor(private definition, private dataRowIndex?: number, private columnData?) {
        this.definition = definition;
        this.dataRowIndex = dataRowIndex;
        this.columnData = columnData;

        if (!definition.effectiveType || !definition.effectiveDataType) {
            throw new Error('Invalid column definition: ' + JSON.stringify(definition));
        }

        this.sources = this.getReferencedTableIds();

        if (definition.hasOwnProperty(jsonConstants.METRIC_DEFINITION_KEY)) {
            var metricDefinitionJson = definition[jsonConstants.METRIC_DEFINITION_KEY];
            if (definition.hasOwnProperty(jsonConstants.BASE_METRIC_DEFINITION_KEY)) {
                metricDefinitionJson = definition[jsonConstants.BASE_METRIC_DEFINITION_KEY];
            }
            this.metricsDefinition = new ColumnMetricsDefinition(metricDefinitionJson);
        }

        this.currencyTypeInfo =
            new CurrencyTypeInfo(definition[jsonConstants.BASE_CURRENCY_TYPE_INFO_KEY]);
        if (!!definition[jsonConstants.BASE_GEO_CONFIG_KEY]) {
            this.geoConfig = new GeoConfig(definition[jsonConstants.BASE_GEO_CONFIG_KEY]);
        }

        this.setupFormatters();
    }

    public getJson() {
        return this.definition;
    }

    /**
     * Gets the unique id generated by callosum for the visualization column
     */
    public getId () : string {
        if (this.definition) {
            return this.definition.id;
        }
    }

    public getGuid () : string {
        return this.getSageOutputColumnId();
    }

    /**
     * Returns the sageOutputColumnId of the VisualizationColumnModel.
     */
    public getSageOutputColumnId () : string {
        return this.definition[jsonConstants.SAGE_OUTPUT_COLUMN_ID_KEY];
    }

    public getFormatPattern () : string {
        return this.definition.formatPattern;
    }

    /**
     * In a given data tuple (or uniques tuple), this number specifies which index
     * corresponds to the data value for this column.
     */
    public getDataRowIndex () : number {
        return this.dataRowIndex;
    }

    public setDataRowIndex (dataRowIndex: number) {
        this.dataRowIndex = dataRowIndex;
    }

    //TODO(Jasmeet): Remove data from viz column.
    public setData (data) {
        this.data = data;
    }

    public getDataFormatter (aggrTypeOverride?: string) : Function {
        if (util.isWholeNumberAggregation(aggrTypeOverride)) {
            return this.numericFormatterInstance;
        }
        if (util.isDoubleNumberAggregation(aggrTypeOverride)) {
            return this.floatingPointFormatterInstance;
        }
        return this.baseTypeFormatterInstance;
    }

    public convertValueFromBackend (dataValue: number, aggrType: string) : number {
        if ((this.isDateColumn() || this.isTimeColumn())
            && !isNaN(dataValue) && dataValue !== null
            && aggrType !== util.aggregateTypes.TOTAL_COUNT
            && aggrType !== util.aggregateTypes.UNIQUE_COUNT) {
            return dataValue * 1000;
        }
        return dataValue;
    }

    public convertValueToBackend (dataValue: number) : number {
        if ((this.isDateColumn() || this.isTimeColumn()) && !isNaN(dataValue)) {
            return dataValue / 1000;
        }
        return dataValue;
    }

    public getName (skipPrefix = false) : string {
        var colName = this.getUnderlyingColumnName();

        if (skipPrefix) {
            return colName;
        }

        var title = util.getAggregateTitle(colName, this.getEffectiveAggregateType());

        if (this.definition && this.definition.growth) {
            // TODO(Jasmeet): Move this to blinkConstants.
            title = 'Growth of ' + title;
        }

        title = util.getTimeBucketizedTitle(title, this.getTimeBucket());

        return title;
    }

    public getUnderlyingColumnName () : string {
        if (this.isInAnswerFormula()) {
            return this.definition.baseColumnName;
        } else {
            var referencedColumnHeaders = this.definition.referencedColumnHeaders;
            var referencedColumnNames = referencedColumnHeaders ?
                referencedColumnHeaders.map(function(header) {
                    return header.name;
                }) : [];
            if (referencedColumnNames.length === 1) {
                return referencedColumnNames[0];
            } else {
                this.logger.info('There should only be one referenced column' +
                             'for non-answer-formula vizColumn unless this' +
                             'is a geofilter');
                return this.definition.baseColumnName;
            }
        }
    }

    public getSources () {
        return this.sources;
    }

    public getSourcesTooltip () : string {
        return this.getSourceName();
    }

    public getBaseAggregationType(): any {
        return this.definition.baseAggrType;
    }

    public getAllReferencedColumns() {
        var columns = this.definition.allLevelReferencedColumnHeaders;
        return columns || [];
    }

    public getReferencedColumnIds(): any {
        var columnHeaders = this.definition.referencedColumnHeaders;
        return columnHeaders ?
            columnHeaders.map(function(header) {
                return header.id;
            }) : [];
    }

    public getBaseColumnGuid(): any {
        var referencedColumnIds = this.getReferencedColumnIds();
        if (referencedColumnIds.length > 0) {
            return referencedColumnIds[0];
        }
        return null;
    }

    public getOriginLogicalColumnGuid(): string {
        var allReferencedColumns = this.getAllReferencedColumns();
        var numReferencedColumns = allReferencedColumns.length;
        return allReferencedColumns[numReferencedColumns - 1].id;
    }

    public getReferencedTableIds(): any {
        var tableHeaders = this.definition.referencedTableHeaders;
        return tableHeaders ?
            tableHeaders.map(function(header) {
                return header.id;
            }) : [];
    }

    /**
     * Returns the model backing the tooltip information of the column
     * @returns {NameValuePairs}
     */
    public getTooltipInformationModel () {
        let sourcePart = this.getSourcesTooltip();
        let recencyPart = this.getDataRecency();
        let model = new util.NameValuePairs();

        model.add(strings.SOURCE, sourcePart);

        if (!!recencyPart) {
            model.add(strings.UPDATED, recencyPart);
        }

        return model;
    }

    public getDataRecency () {
        let recency = this.getJson()[jsonConstants.vizColumn.DATA_RECENCY];
        if (!_.isNumber(recency)) {
            return '';
        }

        return moment(recency * 1000).fromNow();
    }

    public getSourceName = function () : string {
        if (this.isInAnswerFormula()) {
            return 'Formula';
        } else {
            var referencedTableHeaders = this.definition.referencedTableHeaders;

            if (referencedTableHeaders && referencedTableHeaders.length === 1) {
                return referencedTableHeaders[0].name;
            } else {
                this.logger.error(
                    'There should only be one referenced column for non-answer-formula vizColumn.');
            }
        }
    };

    /**
     * Returns the source column id on which this visualization is built upon.
     * Ignores all intermediate derivation/aggregation levels.
     */
    public getBaseLogicalColumnGuid () : string {
        if (this.getReferencedColumnIds() && this.getReferencedColumnIds().length === 1) {
            return this.getReferencedColumnIds()[0];
        }
        return null;
    }

    public getUniqueCount () : number {
        return this.getJson().uniqueValues;
    }

    /**
     * Possible values are 'DATE', 'INT64', 'STRING', 'FLOAT', 'DOUBLE'.
     * (and maybe more, check with callosum).
     */
    public getEffectiveDataType () : string {
        return this.definition.effectiveDataType;
    }

    public isInteger () : boolean {
        var dataType = this.getEffectiveDataType();
        return dataType === util.dataTypes.INT32 || dataType === util.dataTypes.INT64;
    }

    public isFloat () : boolean {
        var dataType = this.getEffectiveDataType();
        return dataType === util.dataTypes.FLOAT || dataType === util.dataTypes.DOUBLE;
    }

    /**
     * Possible values are 'MEASURE', 'ATTRIBUTE'.
     */
    public getEffectiveType () : string {
        return this.definition.effectiveType;
    }

    /**
     * Possible values are 'NONE', 'SUM', 'AVG' etc
     */
    public getEffectiveAggregateType() : string {
        if (!this.isAggregationApplied() ||
            !this.definition.effectiveAggrType) {
            return util.aggregateTypes.NONE;
        }
        return this.definition.effectiveAggrType;
    }

    /**
     * TODO (Rahul/Ashish): We have slightly convoluted notion of the above
     * getEffetiveAggregateType. In case of an aggregate formula, effectiveAggrType
     * is not NONE while aggrApplied is returned false. Above method returns
     * NONE for these aggregate formula too. The need of pivot tables is to have
     * the true effectiveAggregateType. We need to clearly differentiate and
     * distinctly verify which method is required in what place.
     */
    public getTrueEffectiveAggregateType() : string {
        if (!this.definition.effectiveAggrType) {
            return util.aggregateTypes.NONE;
        }
        return this.definition.effectiveAggrType;
    }
    /**
     * Returns a label
     */
    public getEffectiveAggregateLabel () : string {
        return util.getAggregateLabel(this.getEffectiveAggregateType());
    }

    /**
     * Returns true if the viz column overrides the base logical column default aggregation.
     */
    public hasAggregateOverride () : boolean {
        return this.definition.aggrTypeOverride !== 'NONE';
    }

    public isAggregationApplied () : boolean {
        return this.definition.aggrApplied === true;
    }

    public getAggregateOverride () : string {
        return this.definition.aggrTypeOverride;
    }

    /**
     * Returns whether this column should be shown in the UI or not. Some columns
     * (like currency code column) are included just to provide formatting data for other columns.
     * Callosum will send isVisible=false for those columns.
     */
    public isVisible () : boolean {
        if (_.isUndefined(this.definition.isVisible)) {
            return true;
        }
        return !!this.definition.isVisible;
    }

    /**
     * Returns true if the column is derived from another logic column (like Yearly (Order Date)).
     */
    public isDerived () : boolean {
        // logCol is based on a private worksheet, and is always derived.
        return true;
    }

    /**
     * Returns true if the viz column does not have an effective aggregation on it.
     */
    public isEffectivelyAggregated () : boolean {
        var effectiveAggrType = this.getEffectiveAggregateType(),
            hasEffectiveAggrType = effectiveAggrType !== undefined && effectiveAggrType !== 'NONE';
        if (this.isMeasure()) {
            return hasEffectiveAggrType;
        }
        //for attributes default aggregations are to be disregarded
        return hasEffectiveAggrType && this.hasAggregateOverride();
    }

    public isMeasure () : boolean {
        return this.getEffectiveType().toLowerCase() === 'measure';
    }

    public isAttribute () : boolean {
        return this.getEffectiveType().toLowerCase() === 'attribute';
    }

    /**
     * Returns true if the type of the underlying logical column (not viz column) is measure.
     */
    public isBaseTypeMeasure () : boolean {
        return this.definition.baseType.toLowerCase() === 'measure';
    }

    public getBaseType(): any {
        return this.definition.baseType;
    }

    /**
     * Returns true if the type of the underlying logical column (not viz column) is attribute.
     */
    public isBaseTypeAttribute () : boolean {
        return this.getBaseType().toLowerCase() === 'attribute';
    }

    public getBaseDataType(): any {
        return this.definition.baseDataType;
    }

    public isBaseTypeDate(): any {
        var dataType = this.definition.baseDataType;
        return dataType === 'DATE';
    }

    public isBaseNumeric(): boolean {
        var type = this.getBaseDataType();
        return type === 'INT64' || type === 'INT32' || type === 'FLOAT' || type === 'DOUBLE';
    }

    /**
     * Return true if the underlying logical column is additive (e.g. 'age' v/s 'customer number')
     */
    public isAdditive () : boolean {
        return this.definition.isBaseColumnAdditive === 'undefined'
            || this.definition.isBaseColumnAdditive === true;
    }

    public isAdditiveNumeric () : boolean {
        return this.isAdditive() && this.isBaseNumeric();
    }

    public isEffectivelyNumeric () : boolean {
        return this.isMeasure() || this.isAdditiveNumeric();
    }

    public isEffectivelyNonNumeric () : boolean {
        return !this.isEffectivelyNumeric();
    }

    public isDateColumn () : boolean {
        return this.getEffectiveDataType() === 'DATE' || this.isDateTimeColumn();
    }

    public isTimeColumn () : boolean {
        return this.getEffectiveDataType() === 'TIME';
    }

    public isDateTimeColumn () : boolean {
        return this.getEffectiveDataType() === 'DATE_TIME';
    }

    public isDateNumColumn () : boolean {
        return dateUtil.dateNumTypes.hasOwnProperty(this.getEffectiveDataType());
    }

    public isDateFamilyColumn () : boolean {
        return this.isDateColumn() || this.isDateNumColumn();
    }

    public getGeoConfig(): GeoConfig|undefined {
        return this.geoConfig;
    }

    public isGeoColumn(): boolean {
        return !!this.geoConfig;
    }

    public getCurrencyTypeInfo(): any {
        return this.currencyTypeInfo;
    }

    public isCurrencyColumn(): boolean {
        return !!(this.currencyTypeInfo && this.currencyTypeInfo.getSettingType());
    }

    public getUniqueCurrencyCode() {
        return this.definition._uniqueCurrencyCode;
    }

    public setUniqueCurrencyCode = function (isoCode) {
        // The reason why we are setting this as a field of colJson and not as a top level field,
        // is so that when a new VizColumn/LogicalColumn is created for the same column, this value
        // reflect in the new object too.
        this.definition._uniqueCurrencyCode = isoCode;
    };

    public isDoubleColumn () : boolean {
        return this.getEffectiveDataType() === 'DOUBLE';
    }

    /**
     * Set whether the column is a "filter column". See the getter doc for the meaning of filter
     * column
     */
    public setIsFilterColumn (isFilterColumn: boolean) : void {
        this.isFilterColumnProperty = isFilterColumn;
    }

    /**
     * Returns whether the column is introduced in the answer because of a filter.
     * E.g. in the query "revenue blue"
     * color column is a filter column while revenue column is not
     */
    public isFilterColumn () : boolean {
        return !!this.isFilterColumnProperty;
    }

    public isGroupingColumn () : boolean {
        return !!this.definition[jsonConstants.GROUP_BY_KEY];
    }

    /**
     * Returns true if this column object represents a growth query column.
     */
    public isGrowth () : boolean {
        return !!this.definition[jsonConstants.GROWTH_KEY];
    }

    public isGrowthBy () : boolean {
        return this.isAttribute() && !this.definition[jsonConstants.GROUP_BY_KEY];
    }

    // There is a slight difference in the 2 following definitions of the formula columns.
    //
    // `isFormula` returns true for in answer viz columns as well as
    // viz columns made of logical columns which are formula columns.
    //
    // `isAnswerFormula` is true only for the in answer formulae.
    //
    // We want to remove the isFormula method in the future.

    public isFormula() : boolean {
        return this.definition.isBaseColumnFormulaColumn;
    }

    public isInAnswerFormula() : boolean {
        return !!this.definition.baseColumnFormulaId;
    }

    public getTimeBucket () {
        var bucketization = this.definition.bucketization;

        switch (bucketization) {
            case 'ABS_WEEK_AS_EPOCH':
            case 'WEEK_IN_YEAR_AS_EPOCH':
                return dateUtil.timeBuckets.WEEKLY;
            case 'ABS_MONTH_AS_EPOCH':
                return dateUtil.timeBuckets.MONTHLY;
            case 'ABS_QUARTER_AS_EPOCH':
                return dateUtil.timeBuckets.QUARTERLY;
            case 'ABS_YEAR_AS_EPOCH':
                return dateUtil.timeBuckets.YEARLY;
            case 'ABS_DAY_AS_EPOCH':
                return dateUtil.timeBuckets.DAILY;
            case 'ABS_HOUR_AS_EPOCH':
                return dateUtil.timeBuckets.HOURLY;
            default:
                return dateUtil.timeBuckets.NO_BUCKET;
        }
    }

    public getDateBucketBoundaries (epochValue: number|string) : Array<number|string> {
      if (epochValue === blinkConstants.NULL_VALUE_PLACEHOLDER_LABEL
          || epochValue === blinkConstants.EMPTY_VALUE_PLACEHOLDER_LABEL) {
            return [epochValue];
        }

        if (!this.isDateColumn()) {
            return null;
        }

        if (!this.isDerived()) {
            return [epochValue];
        }

        var timeBucket = this.getTimeBucket();

        switch (timeBucket) {
            case dateUtil.timeBuckets.HOURLY:
                return dateUtil.getHourlyBoundaries(epochValue);
            case dateUtil.timeBuckets.DAILY:
                return [epochValue];
            case dateUtil.timeBuckets.WEEKLY:
                return dateUtil.getWeeklyBoundaries(epochValue);
            case dateUtil.timeBuckets.MONTHLY:
                return dateUtil.getMonthlyBoundaries(epochValue);
            case dateUtil.timeBuckets.QUARTERLY:
                return dateUtil.getQuarterlyBoundaries(epochValue);
            case dateUtil.timeBuckets.YEARLY:
                return dateUtil.getYearlyBoundaries(epochValue);
        }
        return null;
    }

    public isNumeric () : boolean {
        var type = this.getEffectiveDataType();
        return type === 'INT64' || type === 'INT32' || type === 'FLOAT' || type === 'DOUBLE';
    }

    public isPercentColumn () : boolean {
        if (_.isUndefined(this.definition.effectiveFormatType)) {
            var formatPattern = this.getFormatPattern();
            return formatPattern && formatPattern.last() === '%';
        }
        return this.definition.effectiveFormatType === 'PERCENTAGE';
    }

    public isEffectivelyPercent () : boolean {
        return this.isPercentColumn();
    }

    /**
     *
     * Returns true if the data for a viz is sorted on this column as one of
     * the sort keys (primary or n-ary).
     */
    public isSortKey () : boolean {
        return !_.isUndefined(this.definition.sortAscending);
    }

    /**
     * Returns true if asc/desc flag is available.
     */
    public isSorted () : boolean {
        return !_.isUndefined(this.definition.sortAscending);
    }

    /**
     * Returns true if the column is sorted explicitly by the user (via the sage query).
     * Used to tell such cases from cases where callosum uses its own rules to sort columns
     */
    public isUserSorted () : boolean {
        return this.isSorted() && !!this.definition.isUserSorted;
    }

    /**
     * Returns true if the data for a viz is sorted on this column in ascending order,
     * false if descending order.
     */
    public isAscendingSort () : boolean {
        return !!this.definition.sortAscending;
    }

    public isDescendingSort = function () {
        return this.isSorted() && !this.isAscendingSort();
    };

    public getSortIndex = function () {
        return !_.isUndefined(this.definition.sortIndex) ? this.definition.sortIndex : -1;
    };

    public convertValueToSageValue (value) {
        // TODO (sunny): re-use the common code between this method and `convertValueToSageValue`
        // in logical table model.

        // SCAL-11232: in case value is null and already formtted to {Null}, pass it directly to
        // sage
        if (value === blinkConstants.NULL_VALUE_PLACEHOLDER_LABEL
            || value === blinkConstants.EMPTY_VALUE_PLACEHOLDER_LABEL) {
            return value;
        }

        if (this.isDateColumn()) {
            if (this.isDateTimeColumn()) {
                return dateUtil.formatDate(value, 'MM/dd/yyyy HH:mm:ss', true, true);
            } else {
                return dateUtil.formatDate(value, 'MM/dd/yyyy', true, true);
            }
        }
        if (this.isDateNumColumn()) {
            return dateUtil.formatDateNum(this.getEffectiveDataType(), value, true, true)
                .toLowerCase();
        }
        if (this.isTimeColumn()) {
            return dateUtil.formatTimeOfDay(value, 'HH:mm:ss', true, true);
        }
        if (this.isAttribute()) {
            return util.formatDataLabel(value, {
                checkOnlySpecialFormat: true
            });
        }
        if (this.isEffectivelyNumeric()) {
            // Parse as permissively as possible, more restrictive parsing
            // is done at input time.
            return icu4js.numberFormat.parseFloat(value, true);
        }

        return value;
    }

    /**
     * Return true if this column refers to the same entity as the other column.
     */
    public matches (otherColumn: VisualizationColumnModel) : boolean {
        return this.getBaseLogicalColumnGuid() === otherColumn.getBaseLogicalColumnGuid() &&
            this.getBaseAggregationType() === this.getBaseAggregationType() &&
            this.getBaseType() === otherColumn.getBaseDataType() &&
            this.getBaseDataType() === otherColumn.getBaseDataType() &&
            this.getEffectiveAggregateType() === otherColumn.getEffectiveAggregateType() &&
            this.getEffectiveType() === otherColumn.getEffectiveType() &&
            this.getEffectiveDataType() === otherColumn.getEffectiveDataType();
    }

    public isMarkedForDisambiguation () : boolean {
        return (this.definition && this.definition.markedForDisambiguation);
    }

    public getSupportedAggregationTypes () : boolean {
        return util.getSupportedAggregationTypes(
            this.getEffectiveAggregateType(),
            this.isBaseTypeDate(),
            this.isBaseTypeMeasure(),
            this.isBaseTypeAttribute(),
            this.isAdditiveNumeric(),
            this.isEffectivelyAggregated(),
            this.isGrowth()
        );
    }

    public isFilteringSupportedByUI () : boolean {
        if (VisualizationColumnModel.unsupportedAttributeFilterTypes
                .any(this.getEffectiveDataType())
        ) {
            return false;
        }

        return true;
    }

    public supportsDateBucketizationChange () : boolean {
        return this.isDateColumn() || this.isTimeColumn();
    }

    public supportsAggregationChange () : boolean {
        return this.isMeasure() && this.isBaseTypeMeasure() && this.isAggregationApplied();
    }

    public getMetricsDefinition(): ColumnMetricsDefinition {
        return this.metricsDefinition || null;
    }

    public setMetricsDefinition (columnMetricsDefinition) : void {
        this.metricsDefinition = columnMetricsDefinition;
        this.definition[jsonConstants.METRIC_DEFINITION_KEY] = columnMetricsDefinition.toJson();
    }

    /**
     * Logic for determining new sort order if a user performs a sort on a colum.
     *
     * @returns {boolean} the new sort order.
     */
    public getNewSortingOrder(): boolean {
        if (!this.isSorted()) {
            return !this.isNumeric();
        } else {
            return !this.isAscendingSort();
        }
    }

    private showDateFinancialYearFormat() {
        let supportedBucketizations = [
            dateUtil.timeBuckets.QUARTERLY,
            dateUtil.timeBuckets.YEARLY
        ];
        let currentBucketization = this.getTimeBucket();
        let showDateFinancialYearFormat = supportedBucketizations.some((supportedBucketization) => {
            return supportedBucketization === currentBucketization;
        });
        return showDateFinancialYearFormat;
    }

    private setupFormatters() {
        this.baseTypeFormatterInstance = this.genericFormatter.bind(this);
        this.numericFormatterInstance = this.numericFormatter.bind(this);
        this.floatingPointFormatterInstance =
            this.floatingPointFormatter.bind(this);

        let columnInstance = this;
        let formatPattern = this.getFormatPattern();

        if (this.isGeoColumn()) {
            // geo values are always treated literally, no formatting is required
            // important in case of zip, lat/long which can be numeric and formatting
            // them as numbers can cause them to get shortened to business numbers
            this.baseTypeFormatterInstance = function (dataValue){
                return dataValue + '';
            };
        } else if (this.isEffectivelyNumeric()) {
            this.baseTypeFormatterInstance = this.numericFormatter.bind(this);
        } else if (this.isDateColumn()) {
            let showFinancialFormat = this.showDateFinancialYearFormat();
            let isDateTimeColumn = this.isDateTimeColumn();
            // Callosum can send null formatPattern in case data was imported through the ETL.
            if (!formatPattern) {
                if (isDateTimeColumn) {
                    formatPattern = 'MM/dd/yyyy HH:mm:ss';
                } else {
                    formatPattern = 'MM/dd/yyyy';
                }
            }

            this.baseTypeFormatterInstance = function (dataValue, options) {
                let optimizedPattern = optimizeFormatPattern(formatPattern, options);
                return dateUtil.formatDate(
                    dataValue,
                    optimizedPattern,
                    void 0,
                    !showFinancialFormat
                );
            };
        } else if (this.isDateNumColumn()) {
            this.baseTypeFormatterInstance = function (dataValue) {
                return dateUtil.formatDateNum(
                    columnInstance.getEffectiveDataType(),
                    dataValue,
                    formatPattern
                );
            };
        } else if (this.isTimeColumn()) {
            this.baseTypeFormatterInstance = function (dataValue) {
                var formatPattern = columnInstance.getFormatPattern() || 'HH:mm:ss';
                return dateUtil.formatTimeOfDay(dataValue, formatPattern);
            };
        }
    }
}

/**
 * Remove the redundant 'Week' prefix if present
 * Remove year and expand month if omitYear is true
 */
function optimizeFormatPattern(formatPattern, options) {
    // Note: We are not respecting if the user set the format pattern explicitly. As, callosum
    // does not send us info whether the pattern is user set or default (SCAL-11302).
    var optimizedPattern = formatPattern.replace('\'Week\'', '');
    if(options && options.omitYear) {
        optimizedPattern = optimizedPattern.
        replace(/\/?yyyy\/?/, '').
        replace(/([^M]|^)MM([^M]|$)/, ' MMM ');
    }
    return optimizedPattern.
    replace(/\s+/g,' ').
    trim();
}
